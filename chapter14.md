## 第14章 重载操作符与转换

* 重载操作符是具有特殊名称的函数： 保留字 `operator`后接需要定义的操作符符号。
* 可以重载的操作符：

  | \+ | \- | \* | / | % | ^ | & | \| | ~ | ! | , | = |
  |---|---|---|---|---|---|---|---|---|---|---|---|---|
  | < | > | <= | \>= | ++ | = | << | \>> | == | != | && | \|\| | 
  | += | -= | /= | %= | ^= | &= | \|= | \*= | <<= | \>>= | [] | () | 
  | -> | ->* | new | new [] | delete | delete [] |


* 不可以重载的操作符：

  :: | .* | ?: |
  ---|----|----|


* 通过连接其它合法操作符可以创建新的操作符。
* 重载操作符必须具有一个类类型或枚举类型的操作数。（这条规则强制重载操作符不能重新定义用于 **内置类型** 对象的操作符的含义）
* 操作符的 **优先级** 、**结合性** 或 **操作数数目** 不能改变。
* 除了函数调用操作符`operator()`之外，重载操作符时使用默认实参是非法的。
* 重载操作符不能保证操作数的求值顺序，尤其是，不会保证内置 **逻辑与AND** 、 **逻辑或OR** 和 **逗号操作符** 的操作数求值顺序。在`&&`和`||`的重载版本中两个操作数都会求值，而且求值顺序不做规定。即两者的重载版本没有短路特点。
* 大多数重载操作符可以定义为普通非成员函数或成员函数。作为类的成员函数和重载操作符，有一个隐含的`this`形参，限定为第一个操作数。
* 一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员。
* 不要轻易重载有内置含义的操作符： **赋值操作符** 、 **取地址操作符** 和 **逗号操作符** 对类类型操作数有默认的含义。如果不自定义，编译器会生成默认定义：
	* 合成赋值操作符：进行逐个成员赋值。（使用成员自己的赋值操作符进行赋值）
	* 取地址操作符和逗号操作符在类类型对象上执行与在内置类型对象上执行一样。取地址返回对象有内存地址；逗号操作符从左至右计算个表达式的值，并返回最右边操作数的值。
	* 内置逻辑与（&&）和逻辑或（||）操作符。使用短路求值。如果重新定义该操作符，将失去操作符的短路求值特征。
* 重载操作符时选择成员函数还是非成员函数实现的经验：
	* 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->)符操作必须是定义为成员。（定义为非成员时将在编译期报错）
	* 复合赋值通常应定义为类的成员。（定义为非成员函数也不会报错）
	* 改变成员状态或与给定类型紧密联系物其他操作符，如自增、自减、解引用，通常定义为类的成员函数。
	* 对称的操作符，如算术运算、相等操作符、关系操作符和位操作符，最好定义为普通函数。
* 输入操作符必须处理错误和文件结束的可能性。
* 重载箭头操作符必须返回一个指向类类型的指针，或者返回定义了自己的箭头操作符的类类型对象。
* 函数对象函数（重载了调用操作符的类的对象称为函数对象）比函数更加灵活。
* 转换操作符（`conversion operator`）是一种特殊的类成员函数。它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明。对任何可作为函数返回类型（除了`void`类型之外）都可以定义转换函数。一般而言，不允许转换为数组或函数类型。转换为指针类型（数据和函数指针）以及引用类型是可以的。
* 转换函数必须是类的成员函数，不能指定返回类型。并且形参表必须为空。一般不应该改变被转换对象。因此，转换操作符通常定义为const成员。
* 在进行类型转换时，类类型转换之后不能再跟另一个类类型转换。
* 一般而言，给出一个类与两个内置类型这间的转换是不好的做法。
* 不要定义相互转化的类。
* 避免到内置算术类型的转换：
	* 不要定义接受算术运算类型的操作符重载版本。
	* 不要定义转换到一个以上算术类型的转换。
